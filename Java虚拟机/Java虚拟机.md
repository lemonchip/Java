#                                  Java虚拟机

---

### 一  Java内存区域与内存溢出异常

#### 1.运行时数据区域

###### 1.1程序计数器

​	当前线程所执行的字节码行号指示器。

​	每条线程独立拥有，独立存储，“线程的私有内存”。

​	如果线程执行的是java方法，此程序计数器纪录的是正在执行的虚拟机字节码指令的地址，如果在执行本地方法，这个计数器的值为空。

---

###### 1.2虚拟机栈

​	线程私有，生命周期与线程相同。

​	描述的是java方法执行的内存模型。

​	方法在执行时会创建一个栈帧（Stack Frame）,存储局部变量表，操作数栈，动态链接，方法出口信息。

​	Stack OverflowError异常：线程请求的栈深度大于虚拟机所允许的深度。

​	OutofMemoryError异常： 如果扩展申请不到足够内存。

---

###### 1.3本地方法栈

​	与虚拟机栈作用相似，服务于Native方法。

---

###### 1.4 Java堆

​	存放对象和数组实例，线程共享。

​	垃圾收集器的主要区域。

---

###### 1.5 方法区

​	线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码。

---

###### 1.6运行时常量池

​	存放编译期生成的字面量和符号引用。



---

#### 2 HotSpot虚拟机

###### 2.1 对象的创建



---

###### 2.2对象的内存布局

​	分为：对象头、实例数据、对齐填充

​	对象头：自身运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。

​	

----



### 二  垃圾收集器与内存分配策略

---

#### 1对象存活判断

###### 1.1引用计数法

​	判断效率高，但是不能解决对象之间循环引用。

---

###### 1.2可达性分析算法

​	“GC Roots”的对象作为起点，从这些节点开始向下搜索，当一个对象到“GC Roots”没有任何引用链相连时，证明对象不可用。

---

###### 1.3引用

​	强引用：普遍存在，像“Object o = new Object()”

​	软引用：有用但非必须

​	弱引用：非必须，只能存活下次GC收集器工作之前

​	虚引用：不构成任何影响

---

#### 2 垃圾收集算法

	###### 2.1标记-清除算法

​	不足：效率不高，容易产生内存碎片

---

###### 2.2复制算法

​	划分大小相同的两块内存

​	不足：内存使用缩小为原来的一半

---

###### 2.3标记-整理算法

​	按照“标记-清除“算法一样标记可回收对象，在让所有存活对象移动到一端，再清除边界外的内存

---

###### 2.4分代收集算法

---



#### 3.垃圾收集器

---

###### 3.1  Serial收集器

​	特点：单线程。工作时暂停所有工作线程，直到收集结束。

---

###### 3.2  ParNew收集器

​	Serial的多线程版本。

​	使用 -XX:ParallelGCThreads限制垃圾收集线程数。

---

###### 3.3 Parallel Scavenger收集器

​	新生代收集器，使用复制算法，并行多线程。

​	特点：关注点是吞吐量。

---

######3.4 Serial Old收集器

​	Serial 老年代版本。

​	使用标记-整理算法。

---

######3.5 Parallel Old

​	 Parallel Scavenger老年代版本

​	使用标记-整理算法

---

###### **3.6 CMS 收集器**

​	初始标记： “Stop The World”，仅标记GC Roots 能直接关联的对象。

​	并发标记： 进行GC Roots  Tracing过程。

​	重新标记： 修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象。

​	并发清除：与用户线程并发工作。

​	缺点：对CPU资源非常敏感 ，占用一部分CPU资源，导致程序变慢。无法收集浮动垃圾。使用标记-清除算法会产生大量空间碎片。

---

###### 3.7 G1收集器

​	特点：

​		并发并行：

​		分代收集：

​		空间整合：

​		可预测停顿：

​	步骤：

​		初始标记

​		并发标记

​		最终标记

​		筛选回收

把java堆划分大小相等的独立区域，Region 。



---

###### 3.8 GC日志

·

---

#### 4 内存分配与回收策略

---

###### 4.1  对象优先在Eden上分配

​	对象在新生代Eden区分配。当Eden区没有足够的空间分配时，将产生一次Minor GC 。

​	 JVM将整个堆分为三代：YoungGen（新生代）,OldGen（年老代）,和PermGen(持久区)：
​	 Minor GC：通常是指对新生代的回收。
​	 Major GC：通常是指对年老代的回收。
 	Full GC：Major GC除并发gc外均需对整个堆进行扫描和回收。



###### 4.2大对象直接进入老年代



###### 4.3 长期存活的对象将进入老年代

​	虚拟机给每个对象定义一个对象年龄计数器。如果对象在Eden出生并经历过一次Minor GC还存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且年龄加1 ，每熬过一次 年龄就加1，当他年龄到达一定程度时将会晋升为老年代。





---

### 三  类文件结构

#### 1 Class类文件结构

###### 1.1 魔数与Class文件版本

​	每个Class文件的头4个字节称为魔数，作用是确定这个文件是否为一个能被虚拟机接受的Class文件。

​	值为：0xCAFEBABE

​	第5和第6字节为次版本号，第7和第8字节为主版本号。

---

###### 1.2 常量池

​	常量池容量，偏移地址0x00000008

​	主要存放两大常量：字面量和符号引用	

​	字面量：java语言层面的常量如字符串，final的常量等

​	符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

###### 1.3 访问标志

​	识别类或者接口层次的访问信息，包括：这个Class是类还是接口，是否为public，是否定义abstract等。

###### 1.4类索引与父类索引

​	确定继承关系



###### 1.5字段表集合

 用于描述接口或者类中声明的变量。

###### 1.6 方法表集合

​	描述方法信息

###### 1.7 属性集合表





​	

​	







​	











